[{"ref":"https://iganari.github.io/post/2021-05-20_raspi-imager/","title":"Raspberry Pi Imager を使ってみる","section":"post","date":"2021.05.19","body":"Raspberry Pi 用の microSD を新しい方法で作成する話です :)\n 注意点 この記事は下記の記事のアーカイブです ;)\nhttps://iganari.hatenablog.com/entry/2021/05/20/060817\n今記事の情報は執筆当時のものになります \u0026lt;(. . )\u0026gt;\n概要 Raspberry Pi をセットアップするためには、事前に microSD にイメージを焼き込んでから、Raspberry Pi にセットする必要があります\n今までは CUI でイメージの焼き込み作業をすることが多かったのですが、今回は公式( The Raspberry Pi Foundation )がリリースしている Raspberry Pi Imager を使って、microSD にイメージを焼く作業をしてみたいと思います :)\nRaspberry Pi Imager について 公式がリリースしている Raspberry Pi OS をインストールするソフトウェアです\nhttps://www.raspberrypi.org/software/\n様々な OS 用のバージョンが用意されていて、かつ Raspberry Pi OS でも動きます\n  YouTube に使い方を説明している動画も上がっています\nHow to use Raspberry Pi Imager | Install Raspberry Pi OS to your Raspberry Pi (Raspbian)\n  今回は Raspberry Pi Desktop 上にて実行してみたいと思います :)\nやってみる microSD をマウントしておく 既に使用出来る状態になっている Raspberry Pi Desktop に新規で焼き込みをしたい microSD を USB 経由でマウントします\n  Raspberry Pi Imager のインストール Raspberry Pi OS 上に Raspberry Pi Imager をインストールします\n OS の確認  $ cat /etc/os-release PRETTY_NAME=\u0026quot;Raspbian GNU/Linux 10 (buster)\u0026quot; NAME=\u0026quot;Raspbian GNU/Linux\u0026quot; VERSION_ID=\u0026quot;10\u0026quot; VERSION=\u0026quot;10 (buster)\u0026quot; VERSION_CODENAME=buster ID=raspbian ID_LIKE=debian HOME_URL=\u0026quot;http://www.raspbian.org/\u0026quot; SUPPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianForums\u0026quot; BUG_REPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianBugs\u0026quot;  インストール  sudo apt update suto apt install rpi-imager インストールはこれだけです :)\nRaspberry Pi Imager の起動と実行 デスクトップの [ホームボタン] -\u0026gt; [Accessories] -\u0026gt; [Imager] とありますので、これをクリックします\n   クリックするとインストーラーが表示されます  Raspberry Pi 上でやると全画面になってしまった       CHOOSE OS をクリックしてインストールしたい OS を選択します     今回は Raspberry Pi OS (32-bit) の Desktop 版を選択します     次に CHOOSE STORAGE を選択して書き込み先を選択します     今回は microSD を USB接続しているのでこれを選択します     最後に WRITE をクリックします     OS の書き込みをすると、( microSD の )既存のデータが消えてしまうことの注意喚起が出ます  YES を押して、続けましょう       インストールが始まります     書き込みが完了したら USB を抜きましょう    あとは書き込んだ microSD を他の Raspberry Pi にいれ、電源を入れればいつもの Raspberry Pi が起動します\n簡単ですね :)\nまとめ Raspberry Pi Imager を使って Raspberry Pi OS をインストールする一連の流れを見てみました\n( Raspberry Pi Desktop の上からでも )思った以上に簡単に使えたのでこれからはこちらを使って行きたいと思います :)\nHave fan !! :)\n"},{"ref":"https://iganari.github.io/post/2021-05-05_raspi-camra-photo/","title":"Raspberry Pi に Web カメラを接続し、写真の撮影をする","section":"post","date":"2021.05.05","body":"Raspberry Pi に Web カメラを付けて、認識・撮影テストをします :)\n 注意点 この記事は下記の記事のアーカイブです ;)\nhttps://iganari.hatenablog.com/entry/2021/05/05/080354\n今記事の情報は執筆当時のものになります \u0026lt;(. . )\u0026gt;\n概要 Raspberry Pi に Web カメラを付けて、認識・撮影テストをします :)\n記事的には基礎的な構築手順となります\n準備するもの Raspberry Pi  Raspberry Pi 3 Model B  https://www.raspberrypi.org/products/raspberry-pi-3-model-b/\n 実物はこんな感じです     使用している OS  $ cat /etc/os-release PRETTY_NAME=\u0026quot;Raspbian GNU/Linux 10 (buster)\u0026quot; NAME=\u0026quot;Raspbian GNU/Linux\u0026quot; VERSION_ID=\u0026quot;10\u0026quot; VERSION=\u0026quot;10 (buster)\u0026quot; VERSION_CODENAME=buster ID=raspbian ID_LIKE=debian HOME_URL=\u0026quot;http://www.raspbian.org/\u0026quot; SUPPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianForums\u0026quot; BUG_REPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianBugs\u0026quot; Web カメラ  ロジクール Logicool C310n  https://www.logicool.co.jp/ja-jp/products/webcams/hd-webcam-c310n.960-001264.html\n 実物はこんな感じです    実装 USB 接続する 兎にも角にも Web カメラを Raspberry Pi に USB 接続します\n特に注意点はありません ;)\nUSB 接続を CLI から確認する  以下のコマンドを使用して USB 接続を確認します  lsusb ### 例 USB 接続する前 $ lsusb Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ### 例 USB 接続した後 $ lsusb Bus 001 Device 004: ID 046d:081b Logitech, Inc. Webcam C310 \u0026lt;---- 追加された Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub \u0026mdash;\u0026gt; USB 接続は正常に出来ていることが分かりました\nデバイスファイルが作成されているか確認する  サーバ上に USB カメラのデバイスファイルが作成されている方を確認します  ls -la /dev/video* ### 例 USB 接続する前 $ ls -la /dev/video* crw-rw----+ 1 root video 81, 4 May 3 11:03 /dev/video10 crw-rw----+ 1 root video 81, 5 May 3 11:03 /dev/video11 crw-rw----+ 1 root video 81, 6 May 3 11:03 /dev/video12 crw-rw----+ 1 root video 81, 0 May 3 11:03 /dev/video13 crw-rw----+ 1 root video 81, 1 May 3 11:03 /dev/video14 crw-rw----+ 1 root video 81, 2 May 3 11:03 /dev/video15 crw-rw----+ 1 root video 81, 3 May 3 11:03 /dev/video16 ### 例 USB 接続した後 $ ls -la /dev/video* crw-rw----+ 1 root video 81, 9 May 3 11:26 /dev/video0 \u0026lt;---- 追加された crw-rw----+ 1 root video 81, 8 May 3 11:26 /dev/video1 \u0026lt;---- 追加された crw-rw----+ 1 root video 81, 4 May 3 11:03 /dev/video10 crw-rw----+ 1 root video 81, 5 May 3 11:03 /dev/video11 crw-rw----+ 1 root video 81, 6 May 3 11:03 /dev/video12 crw-rw----+ 1 root video 81, 0 May 3 11:03 /dev/video13 crw-rw----+ 1 root video 81, 1 May 3 11:03 /dev/video14 crw-rw----+ 1 root video 81, 2 May 3 11:03 /dev/video15 crw-rw----+ 1 root video 81, 3 May 3 11:03 /dev/video16 \u0026mdash;\u0026gt; /dev/video0 と /dev/video１ が作成されていれば、OK です\nWeb カメラで写真を撮影をする  CLI で Web カメラを実行するために、 fswebcam コマンドをインストールします  sudo apt update sudo apt install -y fswebcam  写真を撮影をします  mkdir ~/camera-test cd ~/camera-test fswebcam image.jpg ### 例 $ fswebcam image.jpg --- Opening /dev/video0... Trying source module v4l2... /dev/video0 opened. No input was specified, using the first. Adjusting resolution from 384x288 to 352x288. --- Capturing frame... Captured frame in 0.00 seconds. --- Processing captured image... Writing JPEG image to 'image.jpg'.  写真が出来ているのを確認します  $ ls -lh total 80K -rw-r--r-- 1 pi pi 78K May 5 05:28 image.jpg   \u0026mdash;\u0026gt; 基本的な使い方はこれだけです :)\n注意点 fswebcam コマンドはデフォルトで /dev/video0 をソース元として指定しています\n故に Web カメラを Raspberry Pi に接続した際に /dev/video0 がちゃんと作成されているか確認して下さい\nまた、同じ現象は Node-Red の node-red-contrib-usbcamera ノード を使った際も発生しますので、しっかり確認しておいて下さい :)\nNode-Red で Web カメラを使う記事も後日作成予定です ;)\nおまけ  fswebcam コマンドのオプションを調べます  かなり多機能なのでこれだけでもいろいろ出来そうですね :)    $ fswebcam --help Usage: fswebcam [\u0026lt;options\u0026gt;] \u0026lt;filename\u0026gt; [[\u0026lt;options\u0026gt;] \u0026lt;filename\u0026gt; ... ] Options: -?, --help Display this help page and exit. -c, --config \u0026lt;filename\u0026gt; Load configuration from file. -q, --quiet Hides all messages except for errors. -v, --verbose Displays extra messages while capturing --version Displays the version and exits. -l, --loop \u0026lt;seconds\u0026gt; Run in loop mode. -b, --background Run in the background. -o, --output \u0026lt;filename\u0026gt; Output the log to a file. -d, --device \u0026lt;name\u0026gt; Sets the source to use. -i, --input \u0026lt;number/name\u0026gt; Selects the input to use. -t, --tuner \u0026lt;number\u0026gt; Selects the tuner to use. -f, --frequency \u0026lt;number\u0026gt; Selects the frequency use. -p, --palette \u0026lt;name\u0026gt; Selects the palette format to use. -D, --delay \u0026lt;number\u0026gt; Sets the pre-capture delay time. (seconds) -r, --resolution \u0026lt;size\u0026gt; Sets the capture resolution. --fps \u0026lt;framerate\u0026gt; Sets the capture frame rate. -F, --frames \u0026lt;number\u0026gt; Sets the number of frames to capture. -S, --skip \u0026lt;number\u0026gt; Sets the number of frames to skip. --dumpframe \u0026lt;filename\u0026gt; Dump a raw frame to file. -s, --set \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; Sets a control value. --revert Restores original captured image. --flip \u0026lt;direction\u0026gt; Flips the image. (h, v) --crop \u0026lt;size\u0026gt;[,\u0026lt;offset\u0026gt;] Crop a part of the image. --scale \u0026lt;size\u0026gt; Scales the image. --rotate \u0026lt;angle\u0026gt; Rotates the image in right angles. --deinterlace Reduces interlace artifacts. --invert Inverts the images colours. --greyscale Removes colour from the image. --swapchannels \u0026lt;c1c2\u0026gt; Swap channels c1 and c2. --no-banner Hides the banner. --top-banner Puts the banner at the top. --bottom-banner Puts the banner at the bottom. (Default) --banner-colour \u0026lt;colour\u0026gt; Sets the banner colour. (#AARRGGBB) --line-colour \u0026lt;colour\u0026gt; Sets the banner line colour. --text-colour \u0026lt;colour\u0026gt; Sets the text colour. --font \u0026lt;[name][:size]\u0026gt; Sets the font and/or size. --no-shadow Disables the text shadow. --shadow Enables the text shadow. --title \u0026lt;text\u0026gt; Sets the main title. (top left) --no-title Clears the main title. --subtitle \u0026lt;text\u0026gt; Sets the sub-title. (bottom left) --no-subtitle Clears the sub-title. --timestamp \u0026lt;format\u0026gt; Sets the timestamp format. (top right) --no-timestamp Clears the timestamp. --gmt Use GMT instead of local timezone. --info \u0026lt;text\u0026gt; Sets the info text. (bottom right) --no-info Clears the info text. --underlay \u0026lt;PNG image\u0026gt; Sets the underlay image. --no-underlay Clears the underlay. --overlay \u0026lt;PNG image\u0026gt; Sets the overlay image. --no-overlay Clears the overlay. --jpeg \u0026lt;factor\u0026gt; Outputs a JPEG image. (-1, 0 - 95) --png \u0026lt;factor\u0026gt; Outputs a PNG image. (-1, 0 - 10) --save \u0026lt;filename\u0026gt; Save image to file. まとめ Raspberry Pi に Web カメラを接続し、写真の撮影をするやり方を書きました\n途中使用した fswebcam コマンドも多機能なので、これから色々使ってみたいと思います\nHave fun !! :)\n"},{"ref":"https://iganari.github.io/post/2021-04-22_install-jenkins-on-raspi/","title":"Raspberry Pi に Jenkins をインストールする","section":"post","date":"2021.04.22","body":"Raspberry Pi に Jenkins をインストールするやり方です :)\n 注意点 この記事は下記の記事のアーカイブです ;)\nhttps://iganari.hatenablog.com/entry/2021/04/22/025532\n今記事の情報は執筆当時のものになります \u0026lt;(. . )\u0026gt;\n概要 宅内に簡単なジョブ基盤が欲しいと思っていたところ、使用していない Raspberry Pi があったので Jenkins をインストールしてみようと思いました\n結果から書くと、公式ドキュメントの通りにやると出来ます :)\nhttps://www.jenkins.io/doc/book/installing/linux/\n実際にやってみる 使用する Raspberry Pi のスペック $ cat /etc/os-release PRETTY_NAME=\u0026quot;Raspbian GNU/Linux 10 (buster)\u0026quot; NAME=\u0026quot;Raspbian GNU/Linux\u0026quot; VERSION_ID=\u0026quot;10\u0026quot; VERSION=\u0026quot;10 (buster)\u0026quot; VERSION_CODENAME=buster ID=raspbian ID_LIKE=debian HOME_URL=\u0026quot;http://www.raspbian.org/\u0026quot; SUPPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianForums\u0026quot; BUG_REPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianBugs\u0026quot; $ uname -a Linux raspi 5.10.17-v7+ #1403 SMP Mon Feb 22 11:29:51 GMT 2021 armv7l GNU/Linux $ cat /proc/version Linux version 5.10.17-v7+ (dom@buildbot) (arm-linux-gnueabihf-gcc-8 (Ubuntu/Linaro 8.4.0-3ubuntu1) 8.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #1403 SMP Mon Feb 22 11:29:51 GMT 2021 Java のインストール  apt を更新する  sudo apt update  インストール出来る最新の OpenJDK を探します  $ sudo apt search openjdk | grep jre WARNING: apt does not have a stable CLI interface. Use with caution in scripts. default-jre/stable 2:1.11-71+b1 armhf default-jre-headless/stable 2:1.11-71+b1 armhf openjdk-10-jre/stable 10.0.2+13-2 armhf openjdk-10-jre-headless/stable 10.0.2+13-2 armhf openjdk-10-jre-zero/stable 10.0.2+13-2 armhf openjdk-11-jre/stable 11.0.9.1+1-1~deb10u2 armhf openjdk-11-jre-headless/stable 11.0.9.1+1-1~deb10u2 armhf openjdk-8-jre/stable 8u212-b01-1+rpi1 armhf openjdk-8-jre-headless/stable 8u212-b01-1+rpi1 armhf openjdk-8-jre-zero/stable 8u212-b01-1+rpi1 armhf openjdk-9-jre/stable 9.0.4+12-4 armhf openjdk-9-jre-headless/stable 9.0.4+12-4 armhf openjdk-9-jre-zero/stable 9.0.4+12-4 armhf  LTS である Java 11 に対応する openjdk-11-jre がインストール出来そうなので、このバージョンをインストールしましょう  参考: AdoptOpenJDK | Support    sudo apt install openjdk-11-jre  OpenJDK の確認します  $ java --version openjdk 11.0.9.1 2020-11-04 OpenJDK Runtime Environment (build 11.0.9.1+1-post-Raspbian-1deb10u2) OpenJDK Server VM (build 11.0.9.1+1-post-Raspbian-1deb10u2, mixed mode) Jenkins のインストール  Jenkins を apt 経由でインストールします  参考 公式ドキュメント    wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - sudo sh -c 'echo deb https://pkg.jenkins.io/debian-stable binary/ \u0026gt; \\ /etc/apt/sources.list.d/jenkins.list' sudo apt-get update sudo apt-get install jenkins  Jenkins のデーモンを確認します  $ sudo systemctl status jenkins ● jenkins.service - LSB: Start Jenkins at boot time Loaded: loaded (/etc/init.d/jenkins; generated) Active: active (exited) since Tue 2021-04-20 22:50:21 JST; 1min 6s ago Docs: man:systemd-sysv-generator(8) Tasks: 0 (limit: 2062) CGroup: /system.slice/jenkins.service Apr 20 22:50:19 raspi systemd[1]: Starting LSB: Start Jenkins at boot time... Apr 20 22:50:19 raspi jenkins[3495]: Correct java version found Apr 20 22:50:19 raspi su[3554]: (to jenkins) root on none Apr 20 22:50:19 raspi su[3554]: pam_unix(su-l:session): session opened for user jenkins by (uid=0) Apr 20 22:50:20 raspi su[3554]: pam_unix(su-l:session): session closed for user jenkins Apr 20 22:50:21 raspi jenkins[3495]: Starting Jenkins Automation Server: jenkins. Apr 20 22:50:21 raspi systemd[1]: Started LSB: Start Jenkins at boot time.  ブラウザから初期設定を行います  http://IP_ADDRESS:8080  準備中…     まずは admin としてログイン \u0026amp; 初期設定を行うために表記されている PATH にあるファイルから admin のパスワードをコピペします     Jenkins の Plugin のインストール画面では suggested を選びます     admin 以外のユーザの作成をします  ここでは作成せずに、admin のまま進めます       Jenkins の URL の設定を入れます  ここも後でゆっくりと設定したほうがいいでしょう       これで初期設定は完了です!!  設定しなかった項目は後ほど設定しましょう       Jenkins のようこそページが見れるようになりました :)    \u0026mdash;\u0026gt; これで Jenkins on Raspberry Pi の基礎構築が完了しました! :)\nその他、最低限設定しておいたほうが良いこと Jenkins の Version  Jenkins の Version はコンフィグに書いてあるので確認出来ます  $ sudo cat /var/lib/jenkins/config.xml | grep \u0026quot;version\u0026quot; | grep -v \u0026quot;xml\u0026quot; \u0026lt;version\u0026gt;2.277.2\u0026lt;/version\u0026gt; Jenkins CLI Jenkins には便利な CLI があるので実行出来るようにしておきましょう\n 以下の URL にアクセスし、 jenkins-cli.jar をダウンロードしておきます  ダウンロード後にサーバにコピーして下さい    http://IP_ADDRESS:8080/cli/  直接サーバ上でダウンロードする場合は以下のようにします  cd /usr/local/bin sudo wget http://localhost:8080/jnlpJars/jenkins-cli.jar sudo chmod 0755 jenkins-cli.jar admin のパスワード  admin の初期パスワードは ${JENKINS_HOME}/secrets/initialAdminPassword にあります  export JENKINS_HOME='/var/lib/jenkins' cat ${JENKINS_HOME}/secrets/initialAdminPassword 記事中にも書きましたが、admin ユーザ以外の設定を必ずしましょう\nログローテートの設定 Jenkins のログに対してのローテートの設定( /etc/logrotate.d/jenkins )を変更しておきます\n 修正前  /var/log/jenkins/jenkins.log /var/log/jenkins/access_log { weekly copytruncate missingok rotate 52 compress delaycompress notifempty }  修正後  /var/log/jenkins/*.log { daily missingok dateext rotate 52 compress delaycompress notifempty create 644 jenkins jenkins sharedscripts postrotate if [ -f /var/run/jenkins ]; then kill -USR1 `cat /var/run/jenkins` fi endscript }  ドライランをします  sudo /usr/sbin/logrotate -dv /etc/logrotate.d/jenkins  強制実行をします  sudo /usr/sbin/logrotate -f /etc/logrotate.d/jenkins Systemd について  固有の状況かもしれませんが、 Jenkins の Systemd の設定が以下の PATH にありました  /run/systemd/generator.late/jenkins.service  内容は以下のようです  /run/systemd/generator.late/jenkins.service    # Automatically generated by systemd-sysv-generator [Unit] Documentation=man:systemd-sysv-generator(8) SourcePath=/etc/init.d/jenkins Description=LSB: Start Jenkins at boot time Before=multi-user.target Before=multi-user.target Before=multi-user.target Before=graphical.target After=remote-fs.target After=network-online.target Wants=network-online.target [Service] Type=forking Restart=no TimeoutSec=5min IgnoreSIGPIPE=no KillMode=process GuessMainPID=no RemainAfterExit=yes SuccessExitStatus=5 6 ExecStart=/etc/init.d/jenkins start ExecStop=/etc/init.d/jenkins stop まとめ Raspberry Pi に Jenkins をインストールし起動するやり方を書きました\n宅内の簡単な処理を行うジョブ基盤としてしばらく使ってみようと思います\nHave fun !! :)\n"},{"ref":"https://iganari.github.io/post/2021-03-25_install-unrar-on-raspi/","title":"Raspbian で unrar コマンドが古かったので最新にした","section":"post","date":"2021.03.25","body":"unrar コマンドをアップデートする話です :)\n 注意点 この記事は下記の記事のアーカイブです ;)\nhttps://iganari.hatenablog.com/entry/2021/03/25/212336\n概要 Raspberry PI 専用の OS である、 Raspbian にて unrar コマンドが古かったので最新にしました\nインターネット上で転がっている情報だとすこし情報が足りなかったので、今回の記事にまとめました\n実際にやってみる 確認  OS のバージョンの確認  $ cat /etc/os-release PRETTY_NAME=\u0026quot;Raspbian GNU/Linux 10 (buster)\u0026quot; NAME=\u0026quot;Raspbian GNU/Linux\u0026quot; VERSION_ID=\u0026quot;10\u0026quot; VERSION=\u0026quot;10 (buster)\u0026quot; VERSION_CODENAME=buster ID=raspbian ID_LIKE=debian HOME_URL=\u0026quot;http://www.raspbian.org/\u0026quot; SUPPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianForums\u0026quot; BUG_REPORT_URL=\u0026quot;http://www.raspbian.org/RaspbianBugs\u0026quot;  アーキテクトの確認  $ uname -a Linux raspberrypi 5.10.17-v7+ #1403 SMP Mon Feb 22 11:29:51 GMT 2021 armv7l GNU/Linux  現状の unrar の確認  $ unrar --version unrar 0.0.1 ---\u0026gt; これが古すぎる  実行ファイルの確認  $ which unrar /usr/bin/unrar $ ls -la /usr/bin/ | grep unrar lrwxrwxrwx 1 root root 23 Mar 24 06:26 unrar -\u0026gt; /etc/alternatives/unrar -rwxr-xr-x 1 root root 31004 Oct 16 2017 unrar-free $ ls -la /etc/alternatives/unrar lrwxrwxrwx 1 root root 19 Mar 24 06:26 /etc/alternatives/unrar -\u0026gt; /usr/bin/unrar-free unrar のアンインストール  古い unrar のアンインストール  sudo apt remove unrar unrar-free  確認  何も出なければOK    which unrar ls -la /usr/bin/ | grep unrar 新しい unrar のインストール  リポジトリの参照先を追加  echo \u0026quot;deb-src http://mirrordirector.raspbian.org/raspbian/ $(cat /etc/os-release | grep VERSION_CODENAME | awk -F\\= '{print $2}') main contrib non-free rpi\u0026quot; | sudo tee -a /etc/apt/sources.list  確認  既存の deb-src をコメントアウトを取ればよいだけの可能性もある…    $ cat /etc/apt/sources.list deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi # Uncomment line below then 'apt-get update' to enable 'apt-get source' #deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi deb-src http://mirrordirector.raspbian.org/raspbian/ buster main contrib non-free rpi  apt のアップデート  sudo apt update  作業ディレクトリを作成  mkdir -p /tmp/unrar-nonfree \u0026amp;\u0026amp; chmod 0777 /tmp/unrar-nonfree \u0026amp;\u0026amp; cd /tmp/unrar-nonfree  unrar-nonfree に必要な依存関係をインストール  sudo apt build-dep unrar-nonfree  unrar-nonfree ソースをダウンロードし、 .deb パッケージをビルド  sudo apt source -b unrar-nonfree  生成された .deb パッケージをインストール  unrar-nonfree のバージョンによって異なるため * を使用    sudo dpkg -i unrar*.deb \u0026mdash;\u0026gt; これでインストールが出来ました :)\n新しい unrar の確認  Version の確認  オプションが version なので注意 help みたいにオプションの説明も入ってくるので head で適宜情報をカットする    unrar version ### 例 $ unrar version | head -n 6 UNRAR 5.61 beta 1 freeware Copyright (c) 1993-2018 Alexander Roshal Usage: unrar \u0026lt;command\u0026gt; -\u0026lt;switch 1\u0026gt; -\u0026lt;switch N\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;files...\u0026gt; \u0026lt;@listfiles...\u0026gt; \u0026lt;path_to_extract\\\u0026gt;  実行ファイルの確認  $ which unrar /usr/bin/unrar $ ls -la /usr/bin/ | grep unrar lrwxrwxrwx 1 root root 23 Mar 24 06:40 unrar -\u0026gt; /etc/alternatives/unrar -rwxr-xr-x 1 root root 389048 Oct 24 2018 unrar-nonfree $ ls -la /etc/alternatives/unrar lrwxrwxrwx 1 root root 22 Mar 24 06:40 /etc/alternatives/unrar -\u0026gt; /usr/bin/unrar-nonfree \u0026mdash;\u0026gt; 今度は unrar-nofree が実体となっていることが分かります\n .deb パッケージを削除  cd \u0026amp;\u0026amp; rm -rv /tmp/unrar-nonfree 注意点 sudo apt source -b unrar-nonfree このコマンド実行中に _apt ユーザで一部作業をするので、 上記のコマンドは _apt ユーザがアクセスし作業出来るディレクトリでやる必要があります\n### 権限エラーの例 W: Download is performed unsandboxed as root as file 'unrar-nonfree_5.6.6-1.dsc' couldn't be accessed by user '_apt'. - pkgAcquire::Run (13: Permission denied) 参考 VadimBrodsky/install-unrar-nonfree-raspbian.sh https://gist.github.com/VadimBrodsky/1f567067e2cd438312bb9fd57095a806 まとめ これで unrar コマンドのアップデート出来ました\nHave fan !! :)\n"},{"ref":"https://iganari.github.io/post/2021-02-15_cloud-build-run-schedule/","title":"[新機能] Cloud Build Trigger が指定した時間に実行( Run on schedule )出来るようになったので試してみる","section":"post","date":"2021.02.15","body":"Cloud Build の追加機能を試してみました :)\n 注意点 この記事は下記の記事のアーカイブです ;)\nhttps://iganari.hatenablog.com/entry/2021/02/15/234246\n概要 Cloud Build の Trigger を指定した時間に実行する機能が追加実装されました。\nその機能をさっそく使ってみようと思います :)\nなお、 2021 年 2 月の時点では Preview となっています。\nCloud Build とは GCP のフルマネージドの CI/CD 基盤であり、昨今の DevOps には欠かせない機能の一つです。\nCloud Build\n今回の追加機能について 今までは Cloud Build を実行するトリガーは、連携している Repository に対してのイベントをフックするか、 API 的に外部から実行するしかありませんでした。\n新しい追加機能は Cloud Build から Cloud Scheduler を直接設定することが出来るようになりました。\nつまり…\n今まで、 Cloud Build を定期実行させたい場合は自分で以下の構成をする必要がありました。\n Cloud Scheduler -\u0026gt; Cloud Pub/Sub -\u0026gt; Cloud Functions -\u0026gt; Cloud Build    今回の追加機能では以下のよう(※ ユーザが実装する部分という意味で)になります。\n Cloud Scheduler -\u0026gt; Cloud Build    意識して管理するコンポーネントが減るので運用負荷が減り、サービス開発においても出来ることが増えるので、早めに習得しておきましょう :)\n公式ドキュメント Creating manual triggers | Scheduling your build\n実際にやってみる Cloud Build Trigger を作成 GCP コンソールより、 Cloud Build をクリック   Cloud Build の API を有効化する(初回のみ)   Cloud Build の画面( History )   Cloud Build の画面( Triggers ) に移動し、 CREATE TRIGGER をクリック   テスト的に Trigger を作成する  Name : run-schedule-test を記入 Event: Manual invocation を選択 Source: cloudbuild.yaml が入っている リポジトリ  サンプルとして下記のソースコードを使用しています GitHub: package-gcp/builds/sample    他の設定はデフォルトのままで。\n設定を入れたら CREATE をクリック\n  Cloud Build Trigger の作成が完了したので RUN をクリック   main ブランチを選択し、 Trigger を実行   History をクリックし、実際の実行結果を確認するために実行中の Build をクリック   Build の内容を確認し、正常に実行出来ているかを確認する   作成した Cloud Build Trigger を定期実行するように設定する Cloud Scheduler の API を有効化する 下記の URL を別タブで開き、 Cloud Scheduler の API を有効化する\nhttps://console.cloud.google.com/marketplace/product/google/cloudscheduler.googleapis.com\n  作成した Trigger のケバブメニュー(縦に3つの点があるボタン)をクリック   Run on schedule をクリック   Cloud Scheduler で使用する Service Account を選択し、 CONTINUE をクリック デフォルトで選択されているものを使用する\n  Cloud Scheduler を実行するリージョンを選択するために、 SET REGION をクリック   Cloud Scheduler を実行するリージョンを選択する asia-northeast1 を選択\n  Cloud Scheduler の設定をする  Name : Cloud Scheduler の Job 名 Frequency: 繰り返しの設定 TimeZone: 繰り返しの設定のタイムゾーン  今回は 5 分毎に実行するように設定する\n  作成完了   History をクリックし、定期実行されるのを待つ   1 時間くらい待った結果、ちゃんと 5 分毎に実行されているのが分かる   まとめ 今回は Cloud Build の追加機能を試してみました。\nサービス開発がより効率的に出来るようになるので、 GA (General Availability) が楽しみですね!!\nなお繰り返しになりますが、この記事を書いている時点ではこの追加機能は Preview なので、ご利用は自己責任かつ計画的にお願いします。\nHave fun !! :)\n"},{"ref":"https://iganari.github.io/post/2021-01-29_support-handson-of-linedc/","title":"LINE DC 主催のハンズオン勉強会のサポート役(講師側)をやってきました","section":"post","date":"2021.01.29","body":"勉強会の講師をしていきたので、その経験の感想です。\n 注意点 この記事は下記の記事のアーカイブです ;)\n https://iganari.hatenablog.com/entry/2021/01/29/171132  概要 LINE Developers Community ( 以下、LINE DC ) が主催する勉強会にて、講師側で参加したので簡単にまとめておきます。\nconnpass [1/27(水)] 【初心者向け】LINEではじめるWebアプリ開発入門ハンズオン [ミニアプリNight]\nhttps://linedevelopercommunity.connpass.com/event/201381/\n当日まで何をやっていたか 過去に何回か勉強会のお手伝いをしている縁があり、LINE DC の鍋島さんに誘われて、今回の勉強会のお手伝いをすることになりました。\n今回のイベントは今までのハンズオンよりももっと基礎的なところから話したいとのことで、クラウドにホスティングする形ではなく Web 周りの基礎講義をした後に、 Katacoda を用いて簡単なハンズオンをしようという流れになりました。\nわたしの場合は主業務の関係上 よく GCP まわりの資料作りやアイデア出し、コード作成などをするのですが、今回はサポート役としてジョインする形です。\nなので、当日までにお手伝い出来るとこはあまりなかったのですが、途中で簡単なデバックのお手伝いなどをしてしていました。\n当日 当日は参加者から来た質問などへの返信と勝手にガヤ担当(コメントスクリーンに積極的にコメントするなど)をしていました :)\nTwiiter にもいつくかコメントを残してます。\n本日はこちらに講師側で参加しております!!(主に質問を返す係です\nどしどし質問して下さい!! (｀･ω･´)ゞhttps://t.co/XWvbxuqTBF#LINEDC #LINE_API\n\u0026mdash; iganari (@iganari_) January 27, 2021  #Katacoda 上で使用出来る IDE タブの中身は #VSCode みたいですね 👀✨#LINEDC #LINE_API pic.twitter.com/0SRRhLDmxU\n\u0026mdash; iganari (@iganari_) January 27, 2021  また、事前準備では出なかったエラー(というか不具合)が当日に出て焦りましたが、その場で原因を特定して修正することで講師・参加者ともにハンズオンを最後までやりきることが出来ました。\nここらへん、デバックのところを少しだけお手伝いたのでサポートとして役に立てたかと思います :)\n今回のイベントは事前準備含め、ほぼお手伝い出来ていない罪悪感があったので、2重の意味でホッとしていました ;)\nまとめ 過去にハンズオンのお手伝いを数回させて頂きましたが、今回も良いイベントだったと思います(準備はほとんど手伝っていませんが…)\nハンズオンのソースコードも一般公開しているので復習が出来るし、それを元に新しく自分でコードを書くことが出来ると思います。\n次は自分でなにかイベントを主催したいな〜となんとく思いました。\nまずはネタ探しから始めてみよかと思います :)\nHave fun !! :)\n"},{"ref":"https://iganari.github.io/post/2021-01-06-new-years-resolutions/","title":"2020年の振り返りと2021年のこれから","section":"post","date":"2021.01.06","body":"2020 年の振り返りと 2021 年の抱負です :)\n 注意点 この記事は下記の記事のアーカイブです :)\n https://iganari.hatenablog.com/entry/2021/01/06/235857  あけましておめでとうございます☀️\n今年もよろしくお願い致します🎍🐄🗻 pic.twitter.com/yYHjQ6BCPY\n\u0026mdash; iganari (@iganari_) December 31, 2020  新年あけましておめでとうございます🎍\nこの記事を書いている時点で既に正月三が日はとうに過ぎていますが、区切りとして 2020 年の振り返りと 2021 年の抱負を残しておこうと思います。\n去年の振り返り記事 -\u0026gt; 2019年の振り返りと2020年のこれから\n2020 年の振り返り 世間的な情勢 兎にも角にも コロナ が猛威を振るいましたね :(\n幸いなことに自分はコロナに罹らず、近親者にも罹った人はいませんでした。\n近親の方・親しい方に感染があった方につきましては、ご心中お察し申し上げます。\n感染拡大を抑えるために世界規模でステイホームを呼びかけられる中、もともと引きこもりなので家の中でコードを書いたり、お酒を飲みながらゲームしたり、 Netflix で映画を見てたりしてました。\n正常運転です :)\n健康面 2019 年に発覚した持病はそのまま良くも悪くもなっていません。こればっかりは長く付き合っていかないといけないのでゆっくり付き合っていきます。\n前にも増して家から出る機会が減ったので、体重が去年のこの時期より 3kg 増えました\u0026hellip; 年末に Fit Boxing 2 を急遽購入して隔日でトレーニング \u0026amp;\u0026amp; 炭水化物を減らし始めました :(\n生活面 コロナの影響を受け、家で仕事を長時間することがメインになったので、家に仕事が出来るちゃんとした机と椅子を設置しました。\nあとは冬場は暖房をつけると頭痛がするので、今冬からデロンギを導入しました。今の所、頭痛も無く快適です :)\n我が家に暖房が来た!!\nこれで冬を越せる!!☃️#DeLonghi #デロンギ pic.twitter.com/xxf9pEFhFe\n\u0026mdash; iganari (@iganari_) December 5, 2020  技術面 仕事面でいうと 7 月頃に、配属しているチームが変わりました。それまでは自分のスキルを生かして働けずなかなか結果を残せずにいましたが、移動後はスキルを活かしつつ前向きな結果を残せつつあります :)\nプライベートでもコミュニティの運営やカンファレンスのスタッフ、ハンズオン回の講師など幅広く経験をさせて頂きました。どれも自分にとっては新鮮かつ先進的な経験でしたので、誘って頂いた皆様に感謝しています :D\n2021 年の抱負 2021 年は比較的に新しいことに多くチャレンジ出来た反面、一個一個の経験に対しての学びや定着が追いついていないように思っています。\n少なくともハンズオン回の講師をやった後はブログにまとめようと考えていたにも関わらず出来ていないので、貴重な経験をしっかり自分のものにするためにもチャレンジは引き続き継続しつつ、アウトプットをしっかりやっていきたいと思っています :(\nサンプルのソースコードは GitHub にまとめ、ブログの記事をこまめに書きつつ、主に Twitter で情報を収集と発信を出来たらいいなと思っています :)\nでは、今年もよろしくお願いします。\nHave fun!! :)\n"},{"ref":"https://iganari.github.io/post/2020-07-27_try-serverless-neg-04/","title":"Serverless NEG を試す ~リソースの削除~","section":"post","date":"2020.07.27","body":"2020/07 時点での Serverless NEG のハンズオン資料です。\n複数の記事に跨って作成しており、5番目の記事になります。\n 構成 この記事の内容は長いため複数の記事に跨って作成しています。\n適宜、興味のある記事を参照して下さい。\n Serverless NEG とは? Cloud RUN, App Engine, Cloud Functions の準備 サブドメインの設定 External HTTP(S) Load Balancer の作成 \u0026lt;本記事\u0026gt; リソースの削除  事前準備  GCP との認証をします。  gcloud auth login -q  GCP コマンドのため、環境変数を設定しておきます。  ### New Setting export _pj_id='Your GCP Project ID' export _common='check-serverless-neg'  GCP Project の設定をしておきます。  gcloud config set project ${_pj_id}  サンプルコードをダウンロードし、本記事のサンプルコードが格納しているディレクトリに移動します。  cd [Your WorkSpace] git clone https://github.com/iganari/package-gcp.git cd package-gcp/compute/networkendpointgroups/serverless やること  ここまでに作成してきたリソースを削除します。  リソースの削除  LB リソースの削除  gcloud compute forwarding-rules delete ${_common}-https-content-rule --global gcloud compute target-https-proxies delete ${_common}-https-proxy gcloud compute ssl-certificates delete ${_common}-www-ssl-cert gcloud compute url-maps remove-path-matcher ${_common}-url-map --path-matcher-name=${_common}-path-matcher gcloud compute url-maps delete ${_common}-url-map gcloud compute backend-services delete ${_common}-backend-service-run --global gcloud compute backend-services delete ${_common}-backend-service-app --global gcloud compute backend-services delete ${_common}-backend-service-func --global  Serverless NEG リソースの削除  gcloud beta compute network-endpoint-groups delete ${_common}-serverless-neg-run --region=asia-northeast1 gcloud beta compute network-endpoint-groups delete ${_common}-serverless-neg-app --region=asia-northeast1 gcloud beta compute network-endpoint-groups delete ${_common}-serverless-neg-func --region=asia-northeast1  静的 IP アドレスの開放  gcloud compute addresses delete ${_common}-example-ip --global まとめ これでリソースの削除も完了です!!\nお疲れさまでした :)\n"},{"ref":"https://iganari.github.io/post/2020-07-27_try-serverless-neg-03/","title":"Serverless NEG を試す ~External HTTP(S) Load Balancer の作成~","section":"post","date":"2020.07.27","body":"2020/07 時点での Serverless NEG のハンズオン資料です。\n複数の記事に跨って作成しており、4番目の記事になります。\n 構成 この記事の内容は長いため複数の記事に跨って作成しています。\n適宜、興味のある記事を参照して下さい。\n Serverless NEG とは? Cloud RUN, App Engine, Cloud Functions の準備 サブドメインの設定 \u0026lt;本記事\u0026gt; External HTTP(S) Load Balancer の作成 リソースの削除  事前準備  GCP との認証をします。  gcloud auth login -q  GCP コマンドのため、環境変数を設定しておきます。  ### New Setting export _pj_id='Your GCP Project ID' export _common='check-serverless-neg'  GCP Project の設定をしておきます。  gcloud config set project ${_pj_id}  サンプルコードをダウンロードし、本記事のサンプルコードが格納しているディレクトリに移動します。  cd [Your WorkSpace] git clone https://github.com/iganari/package-gcp.git cd package-gcp/compute/networkendpointgroups/serverless やること  External HTTP(S) Load Balancer の作成します。  External HTTP(S) Load Balancer の作成 各種の Serverless NEG を作成する  Cloud Run の Serverless NEG を作成する  gcloud beta compute network-endpoint-groups create ${_common}-serverless-neg-run \\ --region=asia-northeast1 \\ --network-endpoint-type=SERVERLESS \\ --cloud-run-service=${_common}-run  App Engine の Serverless NEG を作成する  gcloud beta compute network-endpoint-groups create ${_common}-serverless-neg-app \\ --region=asia-northeast1 \\ --network-endpoint-type=SERVERLESS \\ --app-engine-service=${_common}-app  Cloud Functions の Serverless NEG を作成する  gcloud beta compute network-endpoint-groups create ${_common}-serverless-neg-func \\ --region=asia-northeast1 \\ --network-endpoint-type=SERVERLESS \\ --cloud-function-name=func  作成した NEG を確認します。  :warning: 2020年7月現在は、GCP コンソール上では確認することが出来ません(※ β版)    gcloud beta compute network-endpoint-groups list ### 例 # gcloud beta compute network-endpoint-groups list NAME LOCATION ENDPOINT_TYPE SIZE check-serverless-neg-serverless-neg-app asia-northeast1 SERVERLESS 0 check-serverless-neg-serverless-neg-func asia-northeast1 SERVERLESS 0 check-serverless-neg-serverless-neg-run asia-northeast1 SERVERLESS 0 各種の Backend Service を作成する  Cloud Run 用の Backend Service を作成します。  gcloud compute backend-services create ${_common}-backend-service-run \\ --global  App Engine 用の Backend Service を作成します。  gcloud compute backend-services create ${_common}-backend-service-app \\ --global  Cloud Functions 用の Backend Service を作成します。  gcloud compute backend-services create ${_common}-backend-service-func \\ --global  Backend Service を確認します。  gcloud compute backend-services list ### 例 # gcloud compute backend-services list NAME BACKENDS PROTOCOL check-serverless-neg-backend-service-app HTTP check-serverless-neg-backend-service-func HTTP check-serverless-neg-backend-service-run HTTP Backend Service に Cloud Run 用の Serverless NEG を設定する  Cloud Run 用の Backend Service に Cloud Run 用の Serverless NEG を設定します。  gcloud beta compute backend-services add-backend ${_common}-backend-service-run \\ --global \\ --network-endpoint-group=${_common}-serverless-neg-run \\ --network-endpoint-group-region=asia-northeast1  App Engine 用の Backend Service に App Engine 用の Serverless NEG を設定します。  gcloud beta compute backend-services add-backend ${_common}-backend-service-app \\ --global \\ --network-endpoint-group=${_common}-serverless-neg-app \\ --network-endpoint-group-region=asia-northeast1  Cloud Functions 用の Backend Service に Cloud Functions 用の Serverless NEG を設定します。  gcloud beta compute backend-services add-backend ${_common}-backend-service-func \\ --global \\ --network-endpoint-group=${_common}-serverless-neg-func \\ --network-endpoint-group-region=asia-northeast1  Backend Service を確認します。  gcloud compute backend-services list ### Ex. # gcloud compute backend-services list NAME BACKENDS PROTOCOL check-serverless-neg-backend-service-app asia-northeast1/networkEndpointGroups/check-serverless-neg-serverless-neg-app HTTP check-serverless-neg-backend-service-func asia-northeast1/networkEndpointGroups/check-serverless-neg-serverless-neg-func HTTP check-serverless-neg-backend-service-run asia-northeast1/networkEndpointGroups/check-serverless-neg-serverless-neg-run HTTP URL map の作成  Load Balancer で使用する URL map を作成します。  デフォルトは Cloud Run にマッピングするようにします。    gcloud compute url-maps create ${_common}-url-map \\ --default-service ${_common}-backend-service-run  URL map のデフォルト以外の設定をします。  gcloud compute url-maps add-path-matcher ${_common}-url-map \\ --path-matcher-name=${_common}-path-matcher \\ --path-rules \u0026quot;/app=check-serverless-neg-backend-service-app,/func=check-serverless-neg-backend-service-func\u0026quot; \\ --default-service=check-serverless-neg-backend-service-run  URL map を確認します。  gcloud compute url-maps list ### Ex. # gcloud compute url-maps list NAME DEFAULT_SERVICE check-serverless-neg-url-map backendServices/check-serverless-neg-backend-service-run マネージド SSL を設定する  www-ssl-cert という名前で Google マネージド SSL certificate リソースの作成をします。  export _my_domain=$(echo ${_common}.hejda.org) gcloud compute ssl-certificates create ${_common}-www-ssl-cert \\ --domains ${_my_domain}  Certificate リソースの確認をします。  gcloud compute ssl-certificates list ### Ex. # gcloud compute ssl-certificates list NAME TYPE CREATION_TIMESTAMP EXPIRE_TIME MANAGED_STATUS check-serverless-neg-www-ssl-cert MANAGED 2020-07-26T00:35:54.246-07:00 PROVISIONING check-serverless-neg.hejda.org: PROVISIONING Load Balancer で使用する Forwarding Rule の作成  リクエストをプロクシにルーティングする forwarding rule を作成します。  gcloud compute forwarding-rules create ${_common}-https-content-rule \\ --address=${_common}-example-ip \\ --target-https-proxy=${_common}-https-proxy \\ --global \\ --ports=443  Forwarding Rule の確認をします。  gcloud compute forwarding-rules list ### 例 # gcloud compute forwarding-rules list NAME REGION IP_ADDRESS IP_PROTOCOL TARGET check-serverless-neg-https-content-rule 34.107.216.140 TCP check-serverless-neg-https-proxy \u0026mdash;\u0026gt; これで、目的の Serverless NEG を使った External HTTP(S) Load Balancer の作成が完了しました!!\nWeb ブラウザで確認 ここまで作ってきたリソースを Web ブラウザで確認していきます。\nCheck the resources with a Web browser.\n URL map on GCP console.     / は Cloud Run にマッピングされています。     /run は Cloud Run にマッピングされています。     /app は App Engine にマッピングされています。     /func は Cloud Functions にマッピングされています。     上記のルールに該当しない場合は Cloud Run にマッピングされています。    まとめ これで Serverless NEG を使った External HTTP(S) Load Balancer の作成が出来ました!!\n最後に リソースの削除 をします。\nHave fun! :)\n"},{"ref":"https://iganari.github.io/post/2020-07-27_try-serverless-neg-02/","title":"Serverless NEG を試す ~サブドメインの設定~","section":"post","date":"2020.07.27","body":"2020/07 時点での Serverless NEG のハンズオン資料です。\n複数の記事に跨って作成しており、3番目の記事になります。\n 構成 この記事の内容は長いため複数の記事に跨って作成しています。\n適宜、興味のある記事を参照して下さい。\n Serverless NEG とは? Cloud RUN, App Engine, Cloud Functions の準備 \u0026lt;本記事\u0026gt; サブドメインの設定 External HTTP(S) Load Balancer の作成 リソースの削除  事前準備  GCP との認証をします。  gcloud auth login -q  GCP コマンドのため、環境変数を設定しておきます。  ### New Setting export _pj_id='Your GCP Project ID' export _common='check-serverless-neg'  GCP Project の設定をしておきます。  gcloud config set project ${_pj_id}  サンプルコードをダウンロードし、本記事のサンプルコードが格納しているディレクトリに移動します。  cd [Your WorkSpace] git clone https://github.com/iganari/package-gcp.git cd package-gcp/compute/networkendpointgroups/serverless やること  External HTTP(S) Load Balancer で使用するサブドメインの準備をします。  静的 IP アドレスの準備  静的 IP アドレスを確保します。  gcloud compute addresses create ${_common}-example-ip \\ --ip-version=IPV4 \\ --global  確保した静的 IP アドレスを確認します。  gcloud compute addresses describe ${_common}-example-ip \\ --format=\u0026quot;get(address)\u0026quot; \\ --global ### 例 # gcloud compute addresses describe ${_common}-example-ip \\ \u0026gt; --format=\u0026quot;get(address)\u0026quot; \\ \u0026gt; --global 34.107.216.140 Prepare Sub Domain  確保した静的 IP アドレスを、自分で用意したサブドメインの A レコードとして設定します。    まとめ これで External HTTP(S) Load Balancer で使用するサブドメインの準備が出来ました!!\n次は External HTTP(S) Load Balancer の作成 をやっていきます!\nHave fun! :)\n"},{"ref":"https://iganari.github.io/post/2020-07-27_try-serverless-neg-01/","title":"Serverless NEG を試す ~Cloud RUN, App Engine, Cloud Functions の準備~","section":"post","date":"2020.07.27","body":"2020/07 時点での Serverless NEG のハンズオン資料です。\n複数の記事に跨って作成しており、2番目の記事になります。\n 構成 この記事の内容は長いため複数の記事に跨って作成しています。\n適宜、興味のある記事を参照して下さい。\n Serverless NEG とは? \u0026lt;本記事\u0026gt; Cloud RUN, App Engine, Cloud Functions の準備 サブドメインの設定 External HTTP(S) Load Balancer の作成 リソースの削除  事前準備  GCP との認証をします。  gcloud auth login -q  GCP コマンドのため、環境変数を設定しておきます。  ### New Setting export _pj_id='Your GCP Project ID' export _common='check-serverless-neg'  GCP Project の設定をしておきます。  gcloud config set project ${_pj_id}  サンプルコードをダウンロードし、本記事のサンプルコードが格納しているディレクトリに移動します。  cd [Your WorkSpace] git clone https://github.com/iganari/package-gcp.git cd package-gcp/compute/networkendpointgroups/serverless やること  Serverless NEG の backend に設定する Cloud RUN, App Engine, Cloud Functions の準備をします。  Cloud Run のサンプルの準備  Cloud Run のサンプルコードがあるディレクトリに移動します。  cd cloudrun  Cloud Run 上で使用するコンテナイメージを Google Container Registry (GCR) にデプロイします。  gcloud builds submit --tag gcr.io/${_pj_id}/${_common}-run  Cloud Run をデプロイします。  gcloud run deploy ${_common}-run \\ --image gcr.io/${_pj_id}/${_common}-run \\ --platform managed \\ --region asia-northeast1 \\ --allow-unauthenticated ### 例 # gcloud run deploy ${_common}-run \\ \u0026gt; --image gcr.io/${_pj_id}/${_common}-run \\ \u0026gt; --platform managed \\ \u0026gt; --region asia-northeast1 \\ \u0026gt; --allow-unauthenticated Deploying container to Cloud Run service [check-serverless-neg-run] in project [~~~~~~~~~~] region [asia-northeast1] ✓ Deploying new service... Done. ✓ Creating Revision... ✓ Routing traffic... ✓ Setting IAM Policy... Done. Service [check-serverless-neg-run] revision [check-serverless-neg-run-00001-lut] has been deployed and is serving 100 percent of traffic at https://check-serverless-neg-run-3umtulj4sq-an.a.run.app  Web ブラウザで確認します。  上述のデプロイコマンドの出力結果に以下の URL が出力されています。 https://check-serverless-neg-run-3umtulj4sq-an.a.run.app       ルートディレクトリに戻ります。  cd - App Engine のサンプルの準備  App Engine のサンプルコードがあるディレクトリに移動します。  cd appengine  サンプルから app.yaml を作成します。  cat app.yaml.sample | sed \u0026quot;s/YOUR_SERVICE/${_common}-app/g\u0026quot; \u0026gt; app.yaml  App Engine にアプリをデプロイします。  gcloud app deploy  デプロイしたアプリの URL を確認します。  gcloud app browse -s ${_common}-app ### 例 # gcloud app browse -s ${_common}-app Did not detect your browser. Go to this link to view your app: https://check-serverless-neg-app-dot-[~~~~~~~~~~].an.r.appspot.com  Web ブラウザで確認します。  上述のデプロイコマンドの出力結果に以下の URL が出力されています。 https://check-serverless-neg-app-dot-[~~~~~~~~~~].an.r.appspot.com       ルートディレクトリに戻ります。  cd - Cloud Functions のサンプルの準備 cd functions gcloud functions deploy func \\ --runtime python38 \\ --trigger-http \\ --region asia-northeast1 \\ --allow-unauthenticated  Web ブラウザで確認します。  GCP コンソールから、Functions の URL を確認することが出来ます。 https://check-serverless-neg-app-dot-[~~~~~~~~~~].an.r.appspot.com       ルートディレクトリに戻ります。  cd - まとめ これで Serverless NEG の backend に設定する Cloud RUN, App Engine, Cloud Functions の準備が出来ました!!\n次は サブドメインの設定 をやっていきます!\nHave fun! :)\n"},{"ref":"https://iganari.github.io/post/2020-07-27_try-serverless-neg-00/","title":"Serverless NEG を試す ~Serverless NEG とは?~","section":"post","date":"2020.07.27","body":"2020/07 時点での Serverless NEG のハンズオン資料です。\n複数の記事に跨って作成しており、1番目の記事になります。\n 構成 この記事の内容は長いため複数の記事に跨って作成しています。\n適宜、興味のある記事を参照して下さい。\n \u0026lt;本記事\u0026gt; Serverless NEG とは? Cloud RUN, App Engine, Cloud Functions の準備 サブドメインの設定 External HTTP(S) Load Balancer の作成 リソースの削除  やること Serverless Network Endpoint Groups の概要を把握します\nServerless NEG とは? 正式名称は Serverless Network Endpoint Groups です。\nGCP には Network Endpoint Group (NEG) という機能があり、 Zonal Network Endpoint Groups と Internet Network Endpoint Groups という 2 種類の NEG がありました。\n2020/07/08 に GCP のサーバレスなコンポーネントに対応した NEG の Beta 版が出ました。\n リリースノート  https://cloud.google.com/release-notes?hl=en#July_08_2020    現在、 Serverless NEG が対応しているのは Cloud Run, Cloud Functions, App Engine です。\n2020/07/27 の時点では Pre-GA というステータスであり、GA までに機能やサポートの制限の変更がある可能性がある状態です。\n Serverless network endpoint groups overview  https://cloud.google.com/load-balancing/docs/negs/serverless-neg-concepts?hl=en    次の図は、 HTTP(S) Load Balancing model に Serverless NEG がどのように収まるかを示しています。\n上記のように、Load Balancer の実際のバックエンドサービスとして、Cloud Run などを使用することが出来るようになります。\nCloud Run や App Engine などは、単独でも強力なスケーリング機能や高い拡張性があるサーバレスなコンポーネントですが今回のアップデートにより、そのコンポーネントを GCP の強力な Load Balancer のバックエンドに設定することが出来るようになり、構築出来るアプリケーションの拡張性がさらに高くなります。\n上記の図では、Serverless NEG は or で表現されていますが、 URL map などを適宜設定することにより、 1 つの Load Balancer の配下に複数のサーバレスコンポーネントを設定することも出来ます。\n今回は、 1 つの Load Balancer の配下に、Cloud Run, App Engine, Cloud Functions を 1 つずつ設定して、Web ブラウザで挙動を見てみようと思います :)\nまとめ これで Serverless NEG の概要を把握しました!!\n次は Cloud RUN, App Engine, Cloud Functions の準備 をやっていきます!\nHave fun! :)\n"},{"ref":"https://iganari.github.io/post/2020-01-03_new-years-resolutions/","title":"2019年の振り返りと2020年のこれから","section":"post","date":"2020.01.03","body":"2019 年の振り返りと 2020 年の抱負です :)\n 注意点 この記事は下記の記事のアーカイブです ;)\n https://iganari.hatenablog.com/entry/2020/01/03/102216  2019年の振り返りと2020年のこれから   新年あけましておめでとうございます🎍\n2019年は公私ともに再出発の年でした。\n今の気持ちを忘れぬよう、(抽象的にぼかしますが)素直に書いてみようと思います。\n2019年について 2019年に起きた主なこと  引っ越し 転職 持病 再起  2019年は自分にとっては生まれ変わるきっかけを与えてくれた年でした。\n引っ越しについて 部屋が一つ増えました。そのおかげで家にコーディング専用の机を置くことが出来、家でコードを書く環境が整いました。\nまた、アクセス出来る駅が増えました。東京の東側に住んでいるのですが、歩いていける距離に電車の駅が複数あることにより、勉強会の帰り道などで、より早く帰れるようになりました。\n転職について それまでの会社も好きだったのですが、訳あって前線からは遠ざかっていたこともあり、自分に自信が持てず保身にばかり走っていた状況でした。\nその状況を変えるために、転職をしました。\n転職した会社に入って半年経ち、既にいろいろ問題もありますが、チャンスもたくさんある会社なので、ここで出来ることを精一杯やろうと決めています。\n持病が発覚 この歳になって、持病が発覚しました。生死に関わるものではなく、普段の生活にも支障は無いのですが、特効薬みたいなものも未だ見つかっていない病気なので、いまは漢方薬を処方してもらい、長くゆっくり直していく予定です。\n再起について エモい話ですが、自分の怠慢のせいで、人生において1番大切な人との繋がりを無くしてしまいました。すべて自分のせいですが、当時は相当荒れたし、後悔で夜中に目が覚める事は今でも少なくありません。\nただ、自分が変わらないとなにも変わらないことは火を見るより明らかなので、「その人が信じてくれていた自分を信じて、がむしゃらに行動をし成果を出す」と覚悟を決めました。\n何年掛かってもかならず追いついて、今度こそ腹を割って話せるようになると心の奥に誓いを立てました。\n2020年について 決意 2019年下半期、とりわけ10月以降は自分のキャパシティを超えたスケジュール密度で技術領域への挑戦を行いました。2ヶ月間走り続けましたが、今でも自分自身に自信が持てずにいます。\nただ、それでも目をかけてくれる周りの方はたくさんいます。なので、その人たちが信じてくれている自分を信じて走り続けます。\nいつか、自分自身も自分を信じてあげれるようになれるよう走り続けます。\nまた、周りを巻き込むことが出来る能力や、周りを巻き込みたいと思っている人を1番に支援することが出来る能力も合わせて培っていきたいと思っています。\n具体的な技術領域(希望を含む)  Infrastructure as Code  Terraform, Ansible   Programming  Python, Golang   Cloud  GCP, Azure   OSS  Kubernetes, Docker   IoT  Node-RED, Noodl   VUI  LINE Clova    インフラエンジニア出身であり今は SRE に身を置いているので、そのバックグラウンドを元に Infrastructure as Code やサービスの全体設計を俯瞰して考え・話すことが出来るようなりたいと考えています。\nOSS に関しても自分で扱えるようになるだけではなく、翻訳やコミュニティにも貢献していきたいと思っています。\nパブリッククラウドに関しては GCP, Azure をメインに引き続き学んでいきます。\nIoT や VUI は興味こそあるのですが、なかなか手をつける時間を作れていなかったので、意識して作っていこうと思います。\nコミュニティ活動 今の自分を形成しているのはコミュニティがあったからだと思っています。\n参加してたくさんの仲間に会えたことで、本来出会えなかったたくさんの尊敬する方々や、より広い世界とのコミュニケーションを持てるようになりました。\nそういったすべての出会いへの感謝を次の世代つなげるために、今後もコミュニティへの参加およびお手伝いや登壇をより積極的にしていこうと思っています。\nまとめ エモい話も若干入れつつ、2019年の振り返りと2020年のこれからを書いてみました。\n立てた誓いが決してブレぬように心の中で反芻しつつ、自分をとりまく環境に積極的にこれからも挑戦していきたいと思います。\n"}]